\chapter{CPU需求分析}

紧承上一章对指令系统的需求分析，我们将其所依赖的硬件系统分为2大部分：

\begin{enumerate}
    \item {\bf CPU}：硬件系统的核心。需作为白盒实现其全部控制逻辑。
    \item {\bf 外设}：由CPU进行调度。需以黑盒方式集成至CPU之下。
\end{enumerate}

本章主要对CPU部分进行需求分析。其中，流水线承担着指令运行和调度的功能，可谓是CPU的心脏。许多``血管''从中延伸出来，将数据输送到CP0、MMU等多个模块，犹如人体的五脏六腑。
当然，正如心脏需要心房心室，CPU还需要通用寄存器、HI/LO寄存器等用于数据的暂存。

以上的比喻描绘了一个极其粗略的CPU结构蓝图。

本章分为如下几个部分：

\begin{enumerate}
    \item {\bf 指令流水}：详细介绍五级流水线架构，及其可能遇到的冒险问题
    \item {\bf 寄存器}：包括32个通用寄存器与HI/LO寄存器
    \item {\bf CP0}：协处理器CP0
    \item {\bf Control}：用于控制流水线的运行
    \item {\bf MMU}：内存管理单元，用于地址映射
\end{enumerate}

每部分介绍其标准解读或是功能说明。

\section{指令流水}

\emph{流水线}承担着指令运行和调度的功能，在时钟脉冲的作用下周而复始地执行着一条条指令，可谓是CPU的心脏。

何为五级流水线？具体来说，体现在以下2个方面：

\begin{enumerate}
    \item {\bf 每条指令被拆分为5个步骤}：共包括5个硬件单元，每个单元负责其中的一个环节。
    \tablethreeL{名称}{代号}{功能}
        取指 & IF & 从指令存储器中读取指令 \\
        译码 & ID & 指令译码，同时读取寄存器 \\
        执行 & EX & 执行操作，或计算地址 \\
        访存 & MEM & 进行访存操作 \\
        回写 & WB & 将计算结果写入寄存器 \\
    \tableend

    \item {\bf 5个硬件单元并行执行}：在任何一个时钟周期内，上述的5个硬件单元分别在处理第$n+5, n+4, n+3, n+2, n+1$条指令的第1, 2, 3, 4, 5个阶段（如下图所示）：
    \image[4in]{pipeline}{流水线结构}

    硬件单元的并行执行同时有其优点和缺点：

    \begin{itemize}
        % TODO：Please check ok
        \item {\bf 优点}：\emph{并行结构加速指令的执行}。设每条指令每个步骤的平均执行时间为$\triangle t$，则对于一个多周期CPU（无流水线结构）而言，$n$条指令所需时间为$5n\triangle t$；
        而对于流水线结构而言，$n$条指令仅需$(n+4)\triangle t$。可以看出，当指令数目很大时，流水线结构可带来约4倍左右的性能提升。

        \item {\bf 缺点}：\emph{并行结构同样带来了冒险问题}。具体地，有2种情形由此产生：
            \begin{itemize}
                \item {\bf 数据冒险}：例如后一条指令的ID阶段需读取前一条指令在WB阶段才写入的寄存器值，但这在时序上矛盾。
                \item {\bf 控制冒险}：例如跳转指令在ID阶段才能确定目标地址，然而此时其下一条指令（延迟槽指令）已进入流水线的IF阶段。
            \end{itemize}
    \end{itemize}

    % TODO：冒险放在设计文档怎么样？需求文档要不就不展开了 不用展开 设计文档我简单提及了

\end{enumerate}

总体来说，指令流水线需每周期并行执行5条指令，能实现暂停清空等控制逻辑，并且能作为系统的核心，在其上集成各个外设单元。
此外，还需设法解决其中可能涉及的冒险问题。


% \subsection{需求总述}
%
% 总体来看，指令系统对硬件的需求如下：
%
% \begin{enumerate}
%     \item {\bf 流水线架构}：实现流水线框架，使得硬件在每个周期可以并行执行5条指令。此外，还需解决其中可能遇到的控制问题：
%     \begin{itemize}
%         \item {\bf 运行控制}：能够对流水线进行暂停、插空周期或清空等控制干预。
%         \item {\bf 解决冒险}：解决数据冒险、控制冒险。
%     \end{itemize}
%     \item {\bf 指令实现}：在流水线框架上实现ucore所需的47条指令。
%     \item {\bf 外设集成}：能在流水线框架的某些硬件单元集成对外部设备的访问，以辅助实现某些指令（如load/store）。
% \end{enumerate}

\section{寄存器}

如果将流水线比喻成CPU的心脏，那么\emph{寄存器}便好像其中贮存血液的心房，储存着CPU的临时数据。

这里说的``寄存器''，既包括32个通用寄存器，还包括HI/LO寄存器用于存储乘法运算的结果。
寄存器使用FPGA上的逻辑单元实现，它们被贡献出来用于硬件系统的数据存储，因而也成为了CPU的珍贵资源。

尽管与硬件实现关系不大，作为对寄存器功能的补充说明，以下列出各个寄存器在软件编写时的使用惯例：

\tablefourL{所属部分}{寄存器号}{寄存器名}{简介}
    通用寄存器 & \$0 & $zero$ & 常量0，不可写入 \\
              & \$1 & $a_t$ & 保留，用于汇编器 \\
              & \$2-\$3 & $v_0 - v_1$ & 函数返回值 \\
              & \$4-\$7 & $a_0 - a_3$ & 函数参数 \\
              & \$8-\$15 & $t_0 - t_7$ & 调用者保存 \\
              & \$16-\$23 & $s_0 - s_7$ & 被调用者保存 \\
              & \$24-\$25 & $t_8 - t_9$ & 调用者保存 \\
              & \$26-\$27 & $k_0 - k_1$ & 保留，用于异常处理 \\
              & \$28 & $gp$ & 全局指针 \\
              & \$29 & $sp$ & 堆栈指针 \\
              & \$30 & $fp$ & 帧指针 \\
              & \$31 & $ra$ & 返回地址 \\
    \midrule
    HI/LO寄存器 & - & HI/LO & 存储乘法结果 \\
\tableend

无论是通用寄存器，还是HI/LO寄存器，都需要支持2种基本操作：读和写。读操作不改变寄存器中的数据，可以在时钟周期的任意时刻进行，表现为组合逻辑；写操作需要修改寄存器中的数据，因而只能
在时钟的上升沿进行，表现为时序逻辑。

寄存器的读写由使能信号进行控制。

MIPS32标准指令集中，涉及寄存器访问的指令（R型指令）至多同时包括3个通用寄存器。其中2个为读，1个为写。因而，对于通用寄存器而言，只需要支持同时以组合逻辑读2个寄存器，并支持在时钟上升沿
写1个寄存器即可。


\section{CP0}

\emph{CP0}在CPU中居于十分特别的地位。从本质上说，CP0只不过是一些特殊定义的寄存器的集合，与上面所述的通用寄存器、HI/LO寄存器没有本质的不同。
然而，它又像是一个淋巴结，汇集了大量来自CPU其余部分的状态信息。当异常来临，操作系统通过读取其中存储的异常原因等信息来了解CPU的状态，正如淋巴结在人体的免疫过程中发挥着重要的指示作用。

以上对CP0的比喻是十分粗浅且不甚恰切的，然而可帮助读者建立对CP0的直观印象。

具体来说，ucore需要CP0提供的寄存器如下表所示：

\tablethreeL{寄存器号}{寄存器名}{功能}
    0 & $Index$ & TLB阵列的入口索引 \\
    1 & $Random$ & 随机数发生器，产生TLB阵列的随机入口索引 \\
    2 & $EntryLo0$ & TLB偶数虚页入口地址的低32位部分 \\
    3 & $EntryLo1$ & TLB奇数虚页入口地址的低32位部分 \\
    8 & $BadVAddr$ & 最近一次发生访存异常的虚拟地址 \\
    9 & $Count$ & 与$Compare$组成片内计时器，二者中断时发出时钟中断信号 \\
    10 & $EntryHi$ & TLB入口地址的高32位部分 \\
    11 & $Compare$ & 与$Count$组成片内计时器，二者中断时发出时钟中断信号 \\
    12 & $Status$ & CPU当前的多种重要状态，包括异常标志与中断使能等 \\
    13 & $Cause$ & 最近一次异常的原因 \\
    14 & $EPC$ & 最近一次异常时的PC值（如异常发生于延迟槽指令，则为PC-4） \\
    15 & $Ebase$ & 操作系统异常处理程序的入口地址 \\
\tableend

可以看出，在本次实验中，CP0中的寄存器大多可以归纳于以下3大类功能：

\begin{table}[H]
    \centering
    \begin{tabular}{l p{5cm} p{6cm}}
        \toprule
        {\bf 功能分类} & {\bf 主要寄存器} & {\bf 简要描述} \\
        \midrule
        {\bf 时钟模块} & Count、Compare & 二者相等时触发时钟中断。操统依此对进程进行调度 \\
        \midrule
        {\bf 异常控制} & Status、Cause、EPC、Ebase、BadVAddr & 分别保存异常状态、原因、受害指令地址、处理程序地址。特别地，BadVAddr寄存器用于处理TLB相关异常 \\
        \midrule
        {\bf TLB维护} & Index、Random、EntryLo0、EntryLo1、EntryHi、BadVAddr & 分别保存TLB阵列的索引、TLB阵列的随机入口索引、TLB入口地址低位、TLB入口地址高位 \\
        \bottomrule
    \end{tabular}
\end{table}

% TODO：Please check 我看了，没什么毛病
% 我真的不确定下面这些东西写的对不对，基本是靠读代码+看学长文档+Google YY出来的
% 以及也不确定应不应该放在需求文档里
% 请一定一定确认一下里面有没有错

以下按照功能分类，简要说明各个寄存器需提供硬件实现的部分。

\emph{注意：许多寄存器字段需要维护。一些需由硬件确定其应写入的值，而另一些由操统负责决定，硬件只需提供其读写接口即可。这一点在下面的表格中以``硬件维护''1项予以阐明。}

\paragraph{时钟模块}
\begin{enumerate}
    \item {\bf Count寄存器}：

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        Count & 31:0 & 一个不停计数的32位寄存器，其计数频率一般同CPU的时钟频率。当计数达到32位无符号数上限时，从0开始重新计数。 & 是 & R/W \\
    \tableend

    \item {\bf Compare寄存器}：
    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        Compare & 31:0 & 当Count寄存器中的计数值与Compare中的值相等时，产生时钟中断。该中断保持至有数据被写入Compare寄存器。& 是 & R/W \\
    \tableend
\end{enumerate}

\paragraph{异常控制}

\begin{enumerate}
    \item {\bf Status寄存器}：其32位划分为多个字段，用于记录CPU与异常处理相关的多个状态。

    其中，部分字段需由硬件提供实现，简述如下：

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        CU3-CU0 & 31:28 & 对应的协处理器（共4个）是否可用。本实验仅实现CP0，故这几位应保持为常量4'b0001。& 是 & R/W \\
        IM7-IM0 & 15:8 & 对应的中断源（共8个）各自是否被屏蔽。屏蔽时置0。& 否 & R/W \\
        EXL & 1 & 是否处于异常级。异常发生时置1。& 是 & R/W \\
        IE & 0 & 全局中断只能位。使能时为1。 & 否 & R/W \\
    \tableend

    \item {\bf Cause寄存器}：类似Status，其32位划分为多个字段，用于全面地记录最近一次异常的原因。

    其中，部分字段需由硬件提供实现，简述如下：

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        BD & 31 & 当前发生异常的指令是否位于延迟槽中。位于延迟槽时置1。 & 是 & R \\
        IV & 23 & 指明中断异常使用一般异常向量（0x180）还是特殊中断向量（0x200）。 & 否 & R/W \\
        WP & 22 & 观测挂起字段。与调试相关。 & 否 & R/W \\
        IP & 15:10 & 对应硬件中断是否发生。 & 是 & R \\
        IP & 9:8 & 对应软件中断是否发生。 & 是 & R/W \\
        ExcCode & 6:2 & 异常号。具体类型见``ucore需求分析''的``异常处理''一节。& 是 & R \\
    \tableend

    \item {\bf EPC寄存器}：

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        EPC & 31:0 & 用于存储异常返回地址。如触发异常的指令不位于延迟槽中，则存储对应的PC值；否则存储PC - 4。& 是 & R/W \\
    \tableend

    \item {\bf Ebase寄存器}：其32位划分为多个字段，用于保存操作系统的异常处理入口地址。硬件在发生异常时跳转至此处。

    其中，部分字段需由硬件提供实现，简述如下：

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        1 & 31 & 写入时被忽略，读取时返回0。 & 是 & R \\
        0 & 30, 11:10 & 必须写为0，读取时返回0。 & 是 & R \\
        Exception & 29:12 & 操作系统的异常处理入口地址。 & 否 & R/W \\
        CPUNum & 9:0 & 表示CPU数量。本工程仅实现单处理器，置为0即可。 & 是 & R \\
    \tableend

    \item {\bf BadVAddr寄存器}：

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        BadVAddr & 31:0 & 保存最近一次访存异常（TLB MISS）的虚拟地址。& 是 & R \\
    \tableend

\end{enumerate}

\paragraph{TLB维护}

\begin{enumerate}
    \item {\bf Index寄存器}：
    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        P & 31 & 检测故障。 & 否 & R/W \\
        0 & 30:6 & 必须写为0，读取时返回0。 & 是 & R \\
        Index & 5:0 & TLB入口的索引值 & 否 & R/W \\
    \tableend

    \item {\bf Random寄存器}：
    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        0 & 31:6 & 必须写为0，读取时返回0。 & 是 & R \\
        Random & 5:0 & TLB随机索引 & 是 & R \\
    \tableend

    \item {\bf EntryLo0、EntryLo1寄存器}：相当于TLBWI、TLBWR指令的接口。其中EntryLo0管理偶数页入口，EntryLo1管理奇数页入口。

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        0 & 29:26 & 必须写为0，读取时返回0。 & 是 & R \\
        PFN、CDVG & 25:0 & 物理页帧号及状态信息 & 否 & R/W \\
    \tableend

    \item {\bf EntryHi寄存器}：包含用于TLB读、写和访问操作的虚拟地址匹配信息。

    \regtable{字段名}{bit}{描述}{硬件维护}{软件读写}
        VPN2 & 31:13 & 虚拟地址的高19位 & 否 & R/W \\
        0 & 12:8 & 必须写为0，读取时返回0。 & 是 & R \\
        ASID & 7:0 & 地址空间标识符，由操统维护。 & 否 & R/W \\
    \tableend

\end{enumerate}

\section{Control}

Control模块用于控制流水线的清空与暂停，还负责在异常发生时确定PC跳转的目标地址。若仍将流水线比作心脏，Control模块就像是控制心脏搏动的神经。

\paragraph{暂停} 有时一条指令需多个周期完成，如某些访存指令。这时，为保证流水线上各个硬件单元仍满足时序关系，便需要将流水线暂停相应的周期数。
\paragraph{清空} MIPS 32标准要求实现精确异常，因此在发生异常的指令之后的指令尽管已经进入流水线，仍需将流水线清空，以确保其不被执行。
\paragraph{异常处理入口地址} 当发生异常时，需要将PC跳转至操统提供的异常处理入口地址。这一地址需在Control模块中赋值为CP0 Ebase的值，再由Control模块传递至PC模块。

\section{MMU}

MMU为CPU与外设打交道的模块。各个外设可以看做实现了读写功能的黑盒子，经MMU集成至CPU的控制之下。

根据上文``ucore需求分析''的``地址映射''一节，MMU需实现地址映射功能，即将虚拟地址转化为外设的物理地址。其需求细节在那一节中已经充分阐明，此处不再赘述。
