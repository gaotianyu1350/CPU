\chapter{指令系统需求分析}

指令系统是硬件（CPU）对ucore唯一透明可见的接口，也因而成为在``运行ucore''之下的第二级需求。

在对ucore进行需求分析后可知，在指令系统这一层面，一共有45条需要实现的指令。

本章包括如下几个部分：

\begin{enumerate}
    \item {\bf 概述}：对五级流水线架构及其运行方式作一简要概述
    \item {\bf 算术逻辑指令}：共22条，包括加减乘、与或非、移位等指令
    \item {\bf 分支跳转指令}：共10条，包括分支（B）与跳转（J）指令
    \item {\bf 访存指令}：共5条，包括读取（L）与写入（S）指令
    \item {\bf 移动指令}：共2条，包括向HILO寄存器的移动
    \item {\bf 陷入指令}：共1条，包括SYSCALL
    \item {\bf 特权指令}：共5条，包括对CP0的访问、异常返回及TLB异常时使用的指令
    \item {\bf 总结}：以上指令对硬件需求的扼要总结
\end{enumerate}

本章除概述与总结外，每节遵从以下介绍流程：

\begin{enumerate}
    \item {\bf 功能}：简要描述此类指令的功能
    \item {\bf 硬件需求}：为实现此类指令，对硬件的结构和功能需求
    \item {\bf 异常}：此类指令可能触发的异常，或对异常处理的影响
\end{enumerate}

\section{概述}

\subsection{五级流水线}

本次项目计划实现基于\emph{五级流水线}的指令系统。何为五级流水线？具体来说，体现在以下2个方面：

\begin{enumerate}
    \item {\bf 每条指令被拆分为5个步骤}：共包括5个硬件单元，每个单元负责其中的一个环节。
    \tablethreeL{名称}{代号}{简介}
        取指 & IF & 从指令存储器中读取指令 \\
        译码 & ID & 指令译码，同时读取寄存器 \\
        执行 & EX & 执行操作，或计算地址 \\
        访存 & MEM & 进行访存操作 \\
        回写 & WB & 将计算结果写入寄存器 \\
    \tableend

    \item {\bf 5个硬件单元并行执行}：在任何一个时钟周期内，上述的5个硬件单元分别在处理第$n+5, n+4, n+3, n+2, n+1$条指令的第1, 2, 3, 4, 5个阶段（如下图所示）：
    \image[4in]{pipeline}{流水线结构}

    硬件单元的并行执行同时有其优点和缺点：

    \begin{itemize}
        % TODO：Please check
        \item {\bf 优点}：\emph{并行结构加速指令的执行}。设每条指令每个步骤的平均执行时间为$\triangle t$，则对于一个多周期CPU（无流水线结构）而言，$n$条指令所需时间为$5n\triangle t$；
        而对于流水线结构而言，$n$条指令仅需$(n+4)\triangle t$。可以看出，当指令数目很大时，流水线结构可带来约4倍左右的性能提升。

        \item {\bf 缺点}：\emph{并行结构同样带来了冒险问题}。具体地，有2种情形由此产生：
            \begin{itemize}
                \item {\bf 数据冒险}：例如后一条指令的ID阶段需读取前一条指令在WB阶段才写入的寄存器值，但这在时序上矛盾。
                \item {\bf 控制冒险}：例如跳转指令在ID阶段才能确定目标地址，然而此时其下一条指令（延迟槽指令）已进入流水线的IF阶段。
            \end{itemize}
    \end{itemize}

    % TODO：冒险放在设计文档怎么样？需求文档要不就不展开了

\end{enumerate}

\subsection{需求总述}

总体来看，指令系统对硬件的需求如下：

\begin{enumerate}
    \item {\bf 流水线架构}：实现流水线框架，使得硬件在每个周期可以并行执行5条指令。
    \begin{itemize}
        \item {\bf 运行控制}：能够对流水线进行暂停、插空周期或清空等控制干预。
        \item {\bf 解决冒险}：解决数据冒险、控制冒险。
    \end{itemize}
    \item {\bf 指令实现}：在流水线框架上实现ucore所需的45条指令。
    \item {\bf 外设集成}：能在流水线框架的某些硬件单元集成对外部设备的访问，以辅助实现某些指令（如load/store）。
\end{enumerate}

\section{算术逻辑指令}

\subsection{功能}

算术逻辑指令共22条，包括加减乘、与或非、移位等，总结如下：

\tablethreeL{指令}{运算}{描述}
    ADDIU、ADDU & A + B & 无符号数加法 \\
    SUBU & A - B & 无符号数减法 \\
    MULT & A $\times$ B & 乘法 \\
    SLT、SLTI、SLTIU、SLTU & A < B & 符号数比较、无符号数比较 \\
    \midrule
    AND、ANDI & A and B  & 与 \\
    OR、ORI & A or B & 或 \\
    NOR & A nor B & 或非 \\
    XOR、XORI & A xor B & 异或 \\
    SLL、SLLV & A sll B & 逻辑左移 \\
    SRL、SRLV & A srl B & 逻辑右移 \\
    SRA、SRAV & A sra B & 算术右移 \\
    \midrule
    LUI & A = imm || $0^{16}$ & 加载立即数至寄存器 \\
\tableend

\subsection{硬件需求}

这部分对硬件的需求主要体现在ALU上，也即流水线的第3部分（EX）。具体地，ALU需接受2个32位整数及相关控制信号作为输入，并以1个32位整数作为输出。控制信号决定了ALU执行的运算；
此外，运算结果应在WB阶段被写入寄存器。

特别地，乘法运算的结果是一个64位整数，因此需要HI/LO寄存器分别用于存储乘积的高、低32位，而不能存入通用寄存器。这也衍生出了相应的移动指令MFHI等。

重点总结如下：

\tabletwoL{硬件单元}{用途}
    ALU & 位于EX阶段，用于计算2个32位整数的运算结果 \\
    HI/LO寄存器 & 用于存储乘积 \\
\tableend

\subsection{异常}

% TODO：有溢出异常么？
无。

\section{分支跳转指令}

\subsection{功能}

分支跳转指令共10条，包括分支（Branch）与跳转（Jump）2类指令，总结如下：

\tabletwoL{指令}{描述}
    BEQ、BNE、BGEZ、BGTZ、BLEZ、BLTZ & 分支指令，用于有条件跳转。 \\
                                    & 条件包括$==, !=, \geq, >, \leq, <$。 \\
    \midrule
    J、JR & 跳转指令，用于无条件跳转； \\
    JAL、JALR & 同上，但会使用寄存器（常为R[31]）预先保存此前的PC值 \\
\tableend

\subsection{硬件需求}

这部分对硬件的需求主要集中于流水线的设计。此外，由于延迟槽指令的存在，异常处理需增加一些特殊的判断逻辑，详细分析见``异常''部分。

以下简要总结其中与流水线相关的部分，即各个模块需因此增加的接口功能：

\begin{enumerate}
    \item {\bf 取指}：取指阶段需根据控制信号，对PC的下一次取指做出判断：如需跳转，则将PC赋值为跳转目标地址；否则PC照常自增4。
    \item {\bf 译码}：译码阶段需1) 识别分支跳转指令，2) 向取指模块提供与跳转相关的控制信号，3) 向流水线的后续阶段提供当前指令是否为延迟指令的信息，便于异常处理。
    \item {\bf 执行}：执行阶段需对JAL、JALR指令，将其返回地址（也即旧的PC值）作为要写入的寄存器值传入流水线的后续阶段。
    \item {\bf 访存}：无。
    \item {\bf 回写}：无。
\end{enumerate}

\subsection{异常}

分支跳转指令本身不会产生异常。但由于分支跳转指令引入了\emph{延迟槽指令}，这会对异常处理带来额外的判断逻辑。

\image[4in]{branch_delay_slot}{延迟槽指令}

\paragraph{延迟槽指令} 我们规定分支指令后面的指令位置为\emph{分支延迟槽}，其中的指令称为\emph{延迟指令}。由于在计算分支目标地址时，延迟指令已经进入流水线，因而无论跳转发生与否，
它都必然被执行。

\paragraph{异常处理相关} 具体地，在异常处理时，需将异常发生时的指令地址（PC值）存入CP0的EPC寄存器中，以便异常处理结束后返回该地址继续执行。然而如果触发异常的指令为延迟槽指令，则需要
将EPC寄存器的值置为PC-4，而非PC的当前值。这是因为在延迟槽指令之前可能已经发生了跳转，因而其后需继续执行的指令序列应位于跳转的目标地址，而非延迟槽指令之后。

\section{访存指令}
<总表>
    \subsection{功能}
    \subsection{硬件需求}
    \subsection{异常}

\section{陷入指令}
<总表>
    \subsection{功能}
    \subsection{硬件需求}
    \subsection{异常}

\section{特权指令}
<总表>
    \subsection{功能}
    \subsection{硬件需求}
    \subsection{异常}

\subsection{空指令}
<总表>
